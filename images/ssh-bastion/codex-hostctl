#!/usr/bin/env python3
"""Utility for managing codex SSH bastion inventory."""

from __future__ import annotations

import argparse
import datetime as _dt
import fcntl
import json
import os
import pathlib
import sys
from typing import Any, Dict, Iterable, List

DATA_DIR = pathlib.Path(os.environ.get("DATA_DIR", "/var/lib/codex-ssh"))
INVENTORY_FILE = DATA_DIR / "inventory.json"
LABELS_FILE = DATA_DIR / "labels.json"
LOCK_FILE = DATA_DIR / ".inventory.lock"
_motd_env = os.environ.get("CODEX_SSH_MOTD_PATH", "/etc/motd")
MOTD_PATH = pathlib.Path(_motd_env) if _motd_env else None
_motd_base_env = os.environ.get("CODEX_SSH_MOTD_BASE", "/etc/motd.base")
MOTD_BASE_PATH = pathlib.Path(_motd_base_env) if _motd_base_env else None


def _load_json(path: pathlib.Path, default: Any) -> Any:
    if not path.exists():
        return default
    try:
        with path.open("r", encoding="utf-8") as fp:
            return json.load(fp)
    except json.JSONDecodeError:
        return default


def _write_json(path: pathlib.Path, value: Any) -> None:
    tmp_path = path.with_suffix(path.suffix + ".tmp")
    with tmp_path.open("w", encoding="utf-8") as fp:
        json.dump(value, fp, indent=2, sort_keys=True)
        fp.write("\n")
    os.chmod(tmp_path, 0o600)
    os.replace(tmp_path, path)


class InventoryStore:
    def __init__(self) -> None:
        DATA_DIR.mkdir(parents=True, exist_ok=True)
        self._lock_file = LOCK_FILE.open("a+")
        fcntl.flock(self._lock_file.fileno(), fcntl.LOCK_EX)
        self.inventory: List[Dict[str, Any]] = list(_load_json(INVENTORY_FILE, []))
        self.labels: Dict[str, str] = dict(_load_json(LABELS_FILE, {}))

    def save(self) -> None:
        _write_json(INVENTORY_FILE, self.inventory)
        _write_json(LABELS_FILE, self.labels)

    def close(self) -> None:
        try:
            fcntl.flock(self._lock_file.fileno(), fcntl.LOCK_UN)
        finally:
            self._lock_file.close()

    def __enter__(self) -> "InventoryStore":
        return self

    def __exit__(self, exc_type, exc, tb) -> None:
        self.close()


def _normalize_id(target: str, port: int) -> str:
    safe_target = target.replace("/", "_")
    return f"{safe_target}:{port}"


def _split_login(login: str) -> tuple[str, str]:
    if "@" in login:
        user, host = login.split("@", 1)
    else:
        user, host = "", login
    host = host.strip()
    if host.startswith("[") and "]" in host:
        host = host[1 : host.index("]")]
    if ":" in host:
        host = host.split(":", 1)[0]
    return user.strip(), host.strip()


def _find_record(store: InventoryStore, record_id: str) -> Dict[str, Any] | None:
    for item in store.inventory:
        if item.get("id") == record_id:
            return item
    return None


def cmd_record(args: argparse.Namespace) -> int:
    with InventoryStore() as store:
        record_id = args.id or _normalize_id(args.target, args.port)
        now = _dt.datetime.utcnow().replace(tzinfo=_dt.timezone.utc).isoformat()
        entry = _find_record(store, record_id)
        payload = {
            "id": record_id,
            "target": args.target,
            "port": args.port,
            "jump_chain": args.jump_chain,
            "fingerprint": args.fingerprint or "",
            "user": args.user or "",
            "last_seen": now,
        }
        if entry is None:
            store.inventory.append(payload)
        else:
            entry.update(payload)
        store.save()
        _refresh_motd(store)
    return 0


def cmd_learn(args: argparse.Namespace) -> int:
    user, host = _split_login(args.login)
    if not host:
        print("Не удалось определить хост из login.", file=sys.stderr)
        return 1
    jump_chain = [hop for hop in (args.via or []) if hop]
    record_args = argparse.Namespace(
        id=args.id,
        target=host,
        port=args.port,
        jump_chain=jump_chain,
        fingerprint="",
        user=user,
    )
    return cmd_record(record_args)


def _iter_sorted(store: InventoryStore) -> Iterable[Dict[str, Any]]:
    return sorted(store.inventory, key=lambda item: item.get("id", ""))


def cmd_list(args: argparse.Namespace) -> int:
    with InventoryStore() as store:
        rows: List[List[str]] = []
        headers = ["ID", "NAME", "LOGIN", "TARGET", "PORT", "JUMP", "FINGERPRINT", "LAST_SEEN"]
        for entry in _iter_sorted(store):
            record_id = entry["id"]
            user = entry.get("user", "")
            target = entry.get("target", "")
            login = f"{user}@{target}" if user else target
            label = store.labels.get(record_id)
            if label:
                name = label
            else:
                name = login or record_id
            jump_chain = " -> ".join(entry.get("jump_chain", [])) or "direct"
            rows.append([
                record_id,
                name,
                login,
                target,
                str(entry.get("port", "")),
                jump_chain,
                entry.get("fingerprint", ""),
                entry.get("last_seen", ""),
            ])
        widths = [len(h) for h in headers]
        for row in rows:
            for idx, cell in enumerate(row):
                widths[idx] = max(widths[idx], len(cell))
        fmt = "  ".join(f"{{:<{w}}}" for w in widths)
        print(fmt.format(*headers))
        for row in rows:
            print(fmt.format(*row))
    return 0


def cmd_export(args: argparse.Namespace) -> int:
    with InventoryStore() as store:
        payload: List[Dict[str, Any]] = []
        for entry in _iter_sorted(store):
            record_id = entry["id"]
            payload.append(
                {
                    "id": record_id,
                    "name": store.labels.get(record_id, record_id),
                    "target": entry.get("target"),
                    "port": entry.get("port"),
                    "jump_chain": entry.get("jump_chain", []),
                    "user": entry.get("user", ""),
                    "fingerprint": entry.get("fingerprint", ""),
                    "last_seen": entry.get("last_seen", ""),
                }
            )
        if args.format == "json":
            json.dump(payload, sys.stdout, sort_keys=True, separators=(",", ":"))
            sys.stdout.write("\n")
        elif args.format == "pretty-json":
            json.dump(payload, sys.stdout, indent=2, sort_keys=True)
            sys.stdout.write("\n")
        elif args.format == "tsv":
            headers = ["id", "name", "target", "port", "user", "jump_chain", "fingerprint", "last_seen"]
            sys.stdout.write("\t".join(headers) + "\n")
            for entry in payload:
                sys.stdout.write(
                    "\t".join(
                        [
                            str(entry.get("id", "")),
                            str(entry.get("name", "")),
                            str(entry.get("target", "")),
                            str(entry.get("port", "")),
                            str(entry.get("user", "")),
                            ",".join(entry.get("jump_chain", [])),
                            str(entry.get("fingerprint", "")),
                            str(entry.get("last_seen", "")),
                        ]
                    )
                    + "\n"
                )
        else:
            raise SystemExit(f"Unsupported export format: {args.format}")
    return 0


def cmd_rename(args: argparse.Namespace) -> int:
    with InventoryStore() as store:
        record_id = args.id
        entry = _find_record(store, record_id)
        if entry is None:
            print(f"Record '{record_id}' was not found", file=sys.stderr)
            return 1
        if args.name:
            store.labels[record_id] = args.name
        else:
            store.labels.pop(record_id, None)
        store.save()
    return 0


def _load_base_message(header: str = "") -> str:
    if header:
        return header
    env_message = os.environ.get("CODEX_SSH_MOTD")
    if env_message:
        return env_message.rstrip("\n")
    if MOTD_BASE_PATH and MOTD_BASE_PATH.exists():
        try:
            return MOTD_BASE_PATH.read_text(encoding="utf-8").rstrip("\n")
        except Exception:
            pass
    return "Codex SSH bastion"


def _render_motd(store: InventoryStore, header: str = "") -> str:
    lines: List[str] = []
    lines.append(_load_base_message(header))
    if store.inventory:
        lines.append("")
        lines.append("Доступные цели:")
        for entry in _iter_sorted(store):
            record_id = entry["id"]
            label = store.labels.get(record_id)
            target = entry.get("target", "")
            user = entry.get("user", "")
            login = f"{user}@{target}" if user else target
            port = entry.get("port", 22)
            jump_chain = " -> ".join(entry.get("jump_chain", [])) or "direct"
            if label:
                name = label
            else:
                name = login or record_id
            port_suffix = f":{port}" if port and port != 22 else ""
            if jump_chain == "direct":
                lines.append(f" • {name}: {login}{port_suffix}")
            else:
                lines.append(f" • {name}: {login}{port_suffix} через {jump_chain}")
    else:
        lines.append("")
        lines.append("Инвентарь пуст. Используйте ssh/scp/sftp, чтобы добавить записи.")
    lines.append("")
    lines.append("Переименовать цель: codex-hostctl rename <id> <name>")
    lines.append("Экспорт JSON: codex-hostctl export")
    return "\n".join(lines) + "\n"


def _refresh_motd(store: InventoryStore) -> None:
    try:
        dest_path = MOTD_PATH
        if dest_path is None:
            return
        if not dest_path.parent.exists():
            return
        content = _render_motd(store)
        tmp_path = dest_path.with_suffix(dest_path.suffix + ".tmp")
        with tmp_path.open("w", encoding="utf-8") as fh:
            fh.write(content)
        os.chmod(tmp_path, 0o644)
        os.replace(tmp_path, dest_path)
    except Exception:
        return


def cmd_motd(args: argparse.Namespace) -> int:
    with InventoryStore() as store:
        sys.stdout.write(_render_motd(store, args.header))
    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description=__doc__)
    sub = parser.add_subparsers(dest="command", required=True)

    p_record = sub.add_parser("record", help="Записать или обновить цель в инвентаре")
    p_record.add_argument("--id", help="Переопределить идентификатор записи", default=None)
    p_record.add_argument("--target", required=True)
    p_record.add_argument("--port", type=int, default=22)
    p_record.add_argument("--jump-chain", nargs="*", default=[])
    p_record.add_argument("--fingerprint", default="")
    p_record.add_argument("--user", default="")
    p_record.set_defaults(func=cmd_record)

    p_list = sub.add_parser("list", help="Показать таблицу инвентаря")
    p_list.set_defaults(func=cmd_list)

    p_export = sub.add_parser("export", help="Экспортировать инвентарь")
    p_export.add_argument(
        "--format",
        choices=("json", "pretty-json", "tsv"),
        default="pretty-json",
        help="Формат вывода (по умолчанию pretty-json).",
    )
    p_export.set_defaults(func=cmd_export)

    p_rename = sub.add_parser("rename", help="Присвоить понятное имя цели")
    p_rename.add_argument("id")
    p_rename.add_argument("name", nargs="?", default="", help="Новое имя (пусто для удаления)")
    p_rename.set_defaults(func=cmd_rename)

    p_motd = sub.add_parser("motd", help="Сгенерировать сообщение дня")
    p_motd.add_argument("--header", default="")
    p_motd.set_defaults(func=cmd_motd)

    p_learn = sub.add_parser("learn", help="Быстро добавить цель и цепочку переходов")
    p_learn.add_argument("login", help="Формат: user@host или просто host")
    p_learn.add_argument("--port", type=int, default=22)
    p_learn.add_argument("--via", action="append", default=[], help="Промежуточные узлы (можно повторить)")
    p_learn.add_argument("--id", default=None, help="Явно указать идентификатор записи")
    p_learn.set_defaults(func=cmd_learn)

    return parser


def main(argv: List[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
